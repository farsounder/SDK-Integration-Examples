# How to get running on Ubuntu
## Install dependencies

### Install 0MQ
Install [zmq](https://zeromq.org/download/) (may need to sudo) and g++ (if
not installed already)
```bash
apt-get update
apt-get install libzmq3-dev g++
```

### Install a protobuf compiler
Install the protobuf compiler:
```bash
apt-get install protobuf-compiler
```

## Testing configuration
### Test 0MQ setup
Find the zmq library so you can link against it - this changes a bit depending
on the actual linux distro. You can use: `ldconfig -p | grep zmq`

For example on Ubuntu on WSL2 I get:
```bash
$ ldconfig -p | grep zmq

        libzmq.so.5 (libc6,x86-64) => /lib/x86_64-linux-gnu/libzmq.so.5
        libzmq.so (libc6,x86-64) => /lib/x86_64-linux-gnu/libzmq.so

```
Note the location of libzmq. We need this to link our C++ code against when we
compile.

There is a simple example from the 0MQ docs in:
[/ubuntu/examples/hello_world_zmq](/ubuntu/examples/hello_world_zmq) that sets up a req/reply 
verison of hello world on a tcp port.
Compile each file (sender.cpp and receiver.cpp): 
```bash
g++ sender.cpp -L /usr/lib/x86_64-linux-gnu -lzmq -o sender
g++ receiver.cpp -L /usr/lib/x86_64-linux-gnu -lzmq -o receiver
```
Remember to replace the "x86_64-linux-gnu" dir with whereever your libzmq is
located.

And run them in separate terminals, eg Terminal 1:
```bash
./sender
```
Terminal 2:
```bash
./receiver
```
If they both compile and run, your 0MQ install is ready!

### Test protobuf setup

Ame as above, find the protobuf library so you can link against it. You can use:
`ldconfig -p | grep proto` to find it. I get the following on WSL2:

```bash
$ ldconfig -p | grep proto
        libprotoc.so.23 (libc6,x86-64) => /lib/x86_64-linux-gnu/libprotoc.so.23
        libprotobuf.so.23 (libc6,x86-64) => /lib/x86_64-linux-gnu/libprotobuf.so.23
        libprotobuf.so (libc6,x86-64) => /lib/x86_64-linux-gnu/libprotobuf.so
        libprotobuf-lite.so.23 (libc6,x86-64) => /lib/x86_64-linux-gnu/libprotobuf-lite.so.23
        libprotobuf-lite.so (libc6,x86-64) => /lib/x86_64-linux-gnu/libprotobuf-lite.so
```
Note the location for later - in the case above it's `/usr/lib/x86_64-linux-gnu`

Build the tutorial.proto file into C++ files (.cc and .h) using the protobuf-compiler
as:
```bash
protoc --proto_path . --cpp_out . tutorial.proto
```
Then you can compile and run the examples (write_addresses.cpp and
read_addresses.cpp) using g++:

```bash
g++ tutorial.pb.cc write_addresses.cpp  -L /usr/lib/x86_64-linux-gnu -lprotobuf -o write
```

and
```bash
g++ tutorial.pb.cc read_addresses.cpp  -L /usr/lib/x86_64-linux-gnu -lprotobuf -o read
```

If you can build and run these examples, your protobuf set up is good to go!

### SonaSoft Messaging Example
Now that we've confirmed that zmq and protobuf are working, this example will
put them together and show a simple example of how to serialize / deserialize
messages and send them over zermq socks to send and receive data from SonaSoft.

The example interface is located in the `/examples/sonasoft_sdk` directory.

Just like before, we have to build the .proto files that describe the messages
SonaSoft expects to receive into C++ files. The `build_protos.sh` will compile
them and put the resulting files in the 'autogenerated' directory.

If running on ubuntu via WSL2, the host os IP needs to be added to the test
script. On Windows, this can just be localhost (if SonaSoft is running on the
same machine). This might also work with a normal linux machine, but to get it
running using WSL2, it was [required](https://learn.microsoft.com/en-us/windows/wsl/networking).

To get this info, just run: `cat /etc/resolv.conf` and use the ip address
returned under nameserver eg it was `nameserver 192.168.160.1` in my case. Edit
the `kHost` variable in `connect_to_sonasoft.cpp` to match this IP.

Finally compile the protos and interface, linking against the zmq and protobuf libs:
```bash
g++ autogenerated/*.cc connect_to_sonasoft.cpp -L /usr/lib/x86_64-linux-gnu/ -lzmq -lprotobuf -o test_interface
```
Now you can run it with: `./test_interface`, and if SonaSoft is running - send
and receive information from it.

### Running in Docker container
The Linux version of this interface can be run in a Docker container using the
included Dockerfile. If using WSL2, details for configuring Docker Desktop so
you can use it with your WSL2 ubuntu version are here: https://docs.docker.com/desktop/wsl/

To build the image:
```bash
sudo docker build -t test_interface .
```
And then run in interactive mode:
```bash
sudo docker run -itp 61000-62000:61000-62000 test_interface
```

### Windows Firewall Settings
It may be necessary depending on your firewall settings to add a custom rule to
allow connections between your WSL2 instance and Windows. You can use following
command in an Administrator PowerShell to do this:
```powershell
New-NetFirewallRule -DisplayName "WSL" -Direction Inbound -LocalAddress 192.168.160.1 -Action Allow
```
Remember to replace your `-LocalAddress` with the address returned by
`cat /etc/resolv.conf` in your WSL2 instance.
